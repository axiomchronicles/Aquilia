"""Module generator."""

from pathlib import Path
from typing import List
import textwrap


class ModuleGenerator:
    """Generate Aquilia module structure."""
    
    def __init__(
        self,
        name: str,
        path: Path,
        depends_on: List[str],
        fault_domain: str,
        route_prefix: str,
        with_tests: bool = False,
    ):
        self.name = name
        self.path = path
        self.depends_on = depends_on
        self.fault_domain = fault_domain
        self.route_prefix = route_prefix
        self.with_tests = with_tests
    
    def generate(self) -> None:
        """Generate module structure."""
        self.path.mkdir(parents=True, exist_ok=True)
        
        # Create module files
        self._create_module_manifest()
        self._create_init_file()
        self._create_controllers_file()
        self._create_services_file()
        self._create_faults_file()
        
        # Optionally create test routes
        if self.with_tests:
            self._create_test_routes_file()
    
    def _create_module_manifest(self) -> None:
        """Create manifest.py (Python-based module configuration)."""
        deps_list = ', '.join(f'"{dep}"' for dep in self.depends_on) if self.depends_on else ''
        
        content = textwrap.dedent(f'''\
            """
            Module Manifest: {self.name}
            Generated by: aq add module {self.name}
            
            This file defines the module configuration using Python.
            """
            
            from aquilia import Module
            
            
            # Module configuration
            manifest = Module(
                name="{self.name}",
                version="0.1.0",
                description="{self.name.capitalize()} module",
            ).auto_discover(True)
            
            # Routing configuration
            manifest.route_prefix = "{self.route_prefix}"
            
            # Fault handling configuration
            manifest.fault_domain = "{self.fault_domain}"
            manifest.fault_strategy = "propagate"
            
            # Dependencies
            manifest.dependencies = [{deps_list}]
            
            # DI providers (auto-discovered from services.py)
            # Or explicitly declare:
            # manifest.register_providers({{"class": "MyService", "scope": "singleton"}})
            
            # Routes (auto-discovered from controllers.py)
            # Or explicitly declare:
            # manifest.register_controllers("module.controllers:MyController")
            # manifest.register_routes({{"path": "/foo", "handler": "bar"}})
            
            
            # Export for module loader
            __all__ = ["manifest"]
        ''').strip()
        
        (self.path / 'manifest.py').write_text(content)
    
    def _create_init_file(self) -> None:
        """Create __init__.py file."""
        test_import = "\nfrom .test_routes import *" if self.with_tests else ""
        
        content = textwrap.dedent(f'''
            """
            {self.name.capitalize()} Module.
            
            Generated by: aq add module {self.name}
            """
            
            from .controllers import *
            from .services import *
            from .faults import *{test_import}
            
            __module_name__ = "{self.name}"
            __version__ = "0.1.0"
        ''').strip()
        
        (self.path / '__init__.py').write_text(content)
    
    def _create_controllers_file(self) -> None:
        """Create controllers.py file with modern controller architecture."""
        content = textwrap.dedent(f'''
            """
            {self.name.capitalize()} module controllers (request handlers).
            
            This file defines the HTTP endpoints for the {self.name} module
            using the modern Controller architecture with pattern-based routing.
            """
            
            from aquilia import Controller, GET, POST, PUT, DELETE, RequestCtx, Response
            # Uncomment for DI:
            # from .services import {self.name.capitalize()}Service
            from .faults import {self.name.capitalize()}NotFoundFault
            
            
            class {self.name.capitalize()}Controller(Controller):
                """
                Controller for {self.name} endpoints.
                
                Provides RESTful CRUD operations for {self.name}.
                """
                
                prefix = "{self.route_prefix}"
                tags = ["{self.name}"]
                
                # Uncomment for DI (services auto-registered from manifest):
                # def __init__(self, service: {self.name.capitalize()}Service):
                #     self.service = service
                
                @GET("/")
                async def list_{self.name}(self, ctx: RequestCtx):
                    """
                    Get list of {self.name}.
                    
                    Example:
                        GET {self.route_prefix}/ -> {{"items": [...], "total": 0}}
                    """
                    # TODO: Implement list logic
                    # items = await self.service.get_all()
                    items = []
                    
                    return Response.json({{
                        "items": items,
                        "total": len(items)
                    }})
                
                @POST("/")
                async def create_{self.name}(self, ctx: RequestCtx):
                    """
                    Create new {self.name}.
                    
                    Example:
                        POST {self.route_prefix}/
                        Body: {{"name": "Example"}}
                        -> {{"id": 1, "name": "Example"}}
                    """
                    data = await ctx.json()
                    
                    # TODO: Validate and create
                    # item = await self.service.create(data)
                    item = {{"id": 1, **data}}
                    
                    return Response.json(item, status=201)
                
                @GET("/«id:int»")
                async def get_{self.name}(self, ctx: RequestCtx, id: int):
                    """
                    Get single {self.name} by ID.
                    
                    Example:
                        GET {self.route_prefix}/1 -> {{"id": 1, "name": "Example"}}
                    """
                    # TODO: Fetch by ID
                    # item = await self.service.get_by_id(id)
                    # if not item:
                    #     raise {self.name.capitalize()}NotFoundFault(item_id=id)
                    
                    item = {{"id": id, "name": "Example"}}
                    
                    return Response.json(item)
                
                @PUT("/«id:int»")
                async def update_{self.name}(self, ctx: RequestCtx, id: int):
                    """
                    Update {self.name} by ID.
                    
                    Example:
                        PUT {self.route_prefix}/1
                        Body: {{"name": "Updated"}}
                        -> {{"id": 1, "name": "Updated"}}
                    """
                    data = await ctx.json()
                    
                    # TODO: Update logic
                    # item = await self.service.update(id, data)
                    # if not item:
                    #     return Response.json({{"error": "Not found"}}, status=404)
                    
                    item = {{"id": id, **data}}
                    
                    return Response.json(item)
                
                @DELETE("/«id:int»")
                async def delete_{self.name}(self, ctx: RequestCtx, id: int):
                    """
                    Delete {self.name} by ID.
                    
                    Example:
                        DELETE {self.route_prefix}/1 -> 204 No Content
                    """
                    # TODO: Delete logic
                    # deleted = await self.service.delete(id)
                    # if not deleted:
                    #     return Response.json({{"error": "Not found"}}, status=404)
                    
                    return Response(status=204)
        ''').strip()
        
        (self.path / 'controllers.py').write_text(content)
    
    def _create_services_file(self) -> None:
        """Create services.py file."""
        content = textwrap.dedent(f'''
            """
            {self.name.capitalize()} module services (business logic).
            
            Services contain the core business logic and are auto-wired
            via dependency injection.
            """
            
            from typing import Optional, List
            
            
            class {self.name.capitalize()}Service:
                """
                Service for {self.name} business logic.
                
                This service is automatically registered with the DI container
                from the manifest and can be injected into controllers.
                """
                
                def __init__(self):
                    # TODO: Inject dependencies (e.g., repositories, external services)
                    self._storage: List[dict] = []
                    self._next_id = 1
                
                async def get_all(self) -> List[dict]:
                    """Get all items."""
                    return self._storage
                
                async def get_by_id(self, item_id: int) -> Optional[dict]:
                    """Get item by ID."""
                    for item in self._storage:
                        if item["id"] == item_id:
                            return item
                    return None
                
                async def create(self, data: dict) -> dict:
                    """Create new item."""
                    item = {{
                        "id": self._next_id,
                        **data
                    }}
                    self._storage.append(item)
                    self._next_id += 1
                    return item
                
                async def update(self, item_id: int, data: dict) -> Optional[dict]:
                    """Update existing item."""
                    item = await self.get_by_id(item_id)
                    if item:
                        item.update(data)
                    return item
                
                async def delete(self, item_id: int) -> bool:
                    """Delete item."""
                    for i, item in enumerate(self._storage):
                        if item["id"] == item_id:
                            self._storage.pop(i)
                            return True
                    return False
        ''').strip()
        
        (self.path / 'services.py').write_text(content)
    
    def _create_faults_file(self) -> None:
        """Create faults.py file."""
        content = textwrap.dedent(f'''
            """
            {self.name.capitalize()} module faults (error handling).
            
            Faults define domain-specific errors and their recovery strategies.
            They are automatically registered with the fault handling system.
            """
            
            from aquilia.faults import Fault, FaultDomain, Severity, RecoveryStrategy
            
            
            # Define fault domain for this module
            {self.fault_domain} = FaultDomain(
                name="{self.fault_domain}",
                description="{self.name.capitalize()} module faults",
            )
            
            
            class {self.name.capitalize()}NotFoundFault(Fault):
                """
                Raised when {self.name} item is not found.
                
                Recovery: Return 404 response
                """
                
                domain = {self.fault_domain}
                severity = Severity.INFO
                code = "{self.name.upper()}_NOT_FOUND"
                
                def __init__(self, item_id: int):
                    super().__init__(
                        code=self.code,
                        domain=self.domain,
                        message=f"{self.name.capitalize()} with id {{item_id}} not found",
                        metadata={{"item_id": item_id}},
                        retryable=False,
                    )
            
            
            class {self.name.capitalize()}ValidationFault(Fault):
                """
                Raised when {self.name} data validation fails.
                
                Recovery: Return 400 response with validation errors
                """
                
                domain = {self.fault_domain}
                severity = Severity.INFO
                code = "{self.name.upper()}_VALIDATION_ERROR"
                
                def __init__(self, errors: dict):
                    super().__init__(
                        code=self.code,
                        domain=self.domain,
                        message="Validation failed",
                        metadata={{"errors": errors}},
                        retryable=False,
                    )
            
            
            class {self.name.capitalize()}OperationFault(Fault):
                """
                Raised when {self.name} operation fails.
                
                Recovery: Retry with exponential backoff
                """
                
                domain = {self.fault_domain}
                severity = Severity.WARN
                code = "{self.name.upper()}_OPERATION_FAILED"
                
                def __init__(self, operation: str, reason: str):
                    super().__init__(
                        code=self.code,
                        domain=self.domain,
                        message=f"Operation '{{operation}}' failed: {{reason}}",
                        metadata={{"operation": operation, "reason": reason}},
                        retryable=True,
                    )
        ''').strip()
        
        (self.path / 'faults.py').write_text(content)
    
    def _create_test_routes_file(self) -> None:
        """Create test_routes.py file with demo endpoints."""
        content = textwrap.dedent(f'''\
            """
            Test routes for {self.name} module - Additional test endpoints.
            """
            
            from aquilia import Controller, GET, POST, RequestCtx, Response
            
            
            class Test{self.name.capitalize()}Controller(Controller):
                """Test endpoints for {self.name} module verification."""
                
                prefix = "/test-{self.name}"
                tags = ["test", "{self.name}"]
                
                @GET("/hello")
                async def hello(self, ctx: RequestCtx):
                    """Simple hello world test endpoint."""
                    return Response.json({{
                        "message": "Hello from {{self.name}}!",
                        "status": "success",
                        "module": "{self.name}",
                        "controller": "Test{self.name.capitalize()}Controller"
                    }})
                
                @GET("/echo/«message:str»")
                async def echo(self, ctx: RequestCtx, message: str):
                    """Echo back a message with path parameter."""
                    return Response.json({{
                        "echo": message,
                        "length": len(message),
                        "type": "path_param",
                        "module": "{self.name}"
                    }})
                
                @POST("/data")
                async def post_data(self, ctx: RequestCtx):
                    """Test POST with JSON body."""
                    try:
                        data = await ctx.json()
                        return Response.json({{
                            "received": data,
                            "keys": list(data.keys()) if isinstance(data, dict) else None,
                            "status": "processed",
                            "module": "{self.name}"
                        }})
                    except Exception as e:
                        return Response.json({{
                            "error": str(e),
                            "status": "failed"
                        }}, status=400)
                
                @GET("/health")
                async def health(self, ctx: RequestCtx):
                    """Health check endpoint for {self.name} module."""
                    return Response.json({{
                        "status": "healthy",
                        "module": "{self.name}",
                        "controller": "Test{self.name.capitalize()}Controller"
                    }})
        ''').strip()
        
        (self.path / 'test_routes.py').write_text(content)
