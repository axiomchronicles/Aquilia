"""Module generator."""

from pathlib import Path
from typing import List
import textwrap


class ModuleGenerator:
    """Generate Aquilia module structure."""
    
    def __init__(
        self,
        name: str,
        path: Path,
        depends_on: List[str],
        fault_domain: str,
        route_prefix: str,
    ):
        self.name = name
        self.path = path
        self.depends_on = depends_on
        self.fault_domain = fault_domain
        self.route_prefix = route_prefix
    
    def generate(self) -> None:
        """Generate module structure."""
        self.path.mkdir(parents=True, exist_ok=True)
        
        # Create module files
        self._create_module_manifest()
        self._create_init_file()
        self._create_controllers_file()
        self._create_services_file()
        self._create_faults_file()
    
    def _create_module_manifest(self) -> None:
        """Create module.aq manifest."""
        deps_yaml = '\n'.join(f"    - {dep}" for dep in self.depends_on) if self.depends_on else '    []'
        
        content = textwrap.dedent(f"""
            # Module Manifest: {self.name}
            # Generated by: aq add module {self.name}
            
            module:
              name: {self.name}
              version: "0.1.0"
              description: "{self.name.capitalize()} module"
            
            routing:
              prefix: {self.route_prefix}
              
            fault_handling:
              domain: {self.fault_domain}
              strategy: propagate
            
            dependencies:
            {deps_yaml}
            
            providers:
              # DI providers will be auto-discovered from services.py
              # Or explicitly declared here:
              # - class: {self.name.capitalize()}Service
              #   scope: singleton
            
            routes:
              # Routes will be auto-discovered from controllers.py
              # Or explicitly declared here:
              # - controller: {self.name.capitalize()}Controller
              #   prefix: {self.route_prefix}
        """).strip()
        
        (self.path / 'module.aq').write_text(content)
    
    def _create_init_file(self) -> None:
        """Create __init__.py file."""
        content = textwrap.dedent(f'''
            """
            {self.name.capitalize()} Module.
            
            Generated by: aq add module {self.name}
            """
            
            from .controllers import *
            from .services import *
            from .faults import *
            
            __module_name__ = "{self.name}"
            __version__ = "0.1.0"
        ''').strip()
        
        (self.path / '__init__.py').write_text(content)
    
    def _create_controllers_file(self) -> None:
        """Create controllers.py file with modern controller architecture."""
        content = textwrap.dedent(f'''
            """
            {self.name.capitalize()} module controllers (request handlers).
            
            This file defines the HTTP endpoints for the {self.name} module
            using the modern Controller architecture with pattern-based routing.
            """
            
            from aquilia import Controller, GET, POST, PUT, DELETE, RequestCtx, Response
            from typing import Annotated
            # from aquilia.di import Inject  # Uncomment for DI
            # from .services import {self.name.capitalize()}Service
            from .faults import {self.name.capitalize()}NotFoundFault
            
            
            class {self.name.capitalize()}Controller(Controller):
                """
                Controller for {self.name} endpoints.
                
                Provides RESTful CRUD operations for {self.name}.
                """
                
                prefix = "{self.route_prefix}"
                tags = ["{self.name}"]
                
                # Uncomment for DI injection:
                # def __init__(self, service: Annotated[{self.name.capitalize()}Service, Inject()]):
                #     self.service = service
                
                @GET("/")
                async def list_{self.name}(self, ctx: RequestCtx):
                    """
                    Get list of {self.name}.
                    
                    Example:
                        GET {self.route_prefix}/ -> {{"items": [...], "total": 0}}
                    """
                    # TODO: Implement list logic
                    # items = await self.service.get_all()
                    items = []
                    
                    return Response.json({{
                        "items": items,
                        "total": len(items)
                    }})
                
                @POST("/")
                async def create_{self.name}(self, ctx: RequestCtx):
                    """
                    Create new {self.name}.
                    
                    Example:
                        POST {self.route_prefix}/
                        Body: {{"name": "Example"}}
                        -> {{"id": 1, "name": "Example"}}
                    """
                    data = await ctx.json()
                    
                    # TODO: Validate and create
                    # item = await self.service.create(data)
                    item = {{"id": 1, **data}}
                    
                    return Response.json(item, status=201)
                
                @GET("/«id:int»")
                async def get_{self.name}(self, ctx: RequestCtx, id: int):
                    """
                    Get single {self.name} by ID.
                    
                    Example:
                        GET {self.route_prefix}/1 -> {{"id": 1, "name": "Example"}}
                    """
                    # TODO: Fetch by ID
                    # item = await self.service.get_by_id(id)
                    # if not item:
                    #     raise {self.name.capitalize()}NotFoundFault(item_id=id)
                    
                    item = {{"id": id, "name": "Example"}}
                    
                    return Response.json(item)
                
                @PUT("/«id:int»")
                async def update_{self.name}(self, ctx: RequestCtx, id: int):
                    """
                    Update {self.name} by ID.
                    
                    Example:
                        PUT {self.route_prefix}/1
                        Body: {{"name": "Updated"}}
                        -> {{"id": 1, "name": "Updated"}}
                    """
                    data = await ctx.json()
                    
                    # TODO: Update logic
                    # item = await self.service.update(id, data)
                    # if not item:
                    #     return Response.json({{"error": "Not found"}}, status=404)
                    
                    item = {{"id": id, **data}}
                    
                    return Response.json(item)
                
                @DELETE("/«id:int»")
                async def delete_{self.name}(self, ctx: RequestCtx, id: int):
                    """
                    Delete {self.name} by ID.
                    
                    Example:
                        DELETE {self.route_prefix}/1 -> 204 No Content
                    """
                    # TODO: Delete logic
                    # deleted = await self.service.delete(id)
                    # if not deleted:
                    #     return Response.json({{"error": "Not found"}}, status=404)
                    
                    return Response(status=204)
        ''').strip()
        
        (self.path / 'controllers.py').write_text(content)
    
    def _create_services_file(self) -> None:
        """Create services.py file."""
        content = textwrap.dedent(f'''
            """
            {self.name.capitalize()} module services (business logic).
            
            Services contain the core business logic and are auto-wired
            via dependency injection.
            """
            
            from aquilia.di import injectable, Scope
            from typing import Optional, List
            
            
            @injectable(scope=Scope.SINGLETON)
            class {self.name.capitalize()}Service:
                """
                Service for {self.name} business logic.
                
                This service is automatically registered with the DI container
                and can be injected into flows or other services.
                """
                
                def __init__(self):
                    # TODO: Inject dependencies (e.g., repositories, external services)
                    self._storage: List[dict] = []
                    self._next_id = 1
                
                async def get_all(self) -> List[dict]:
                    """Get all items."""
                    return self._storage
                
                async def get_by_id(self, item_id: int) -> Optional[dict]:
                    """Get item by ID."""
                    for item in self._storage:
                        if item["id"] == item_id:
                            return item
                    return None
                
                async def create(self, data: dict) -> dict:
                    """Create new item."""
                    item = {{
                        "id": self._next_id,
                        **data
                    }}
                    self._storage.append(item)
                    self._next_id += 1
                    return item
                
                async def update(self, item_id: int, data: dict) -> Optional[dict]:
                    """Update existing item."""
                    item = await self.get_by_id(item_id)
                    if item:
                        item.update(data)
                    return item
                
                async def delete(self, item_id: int) -> bool:
                    """Delete item."""
                    for i, item in enumerate(self._storage):
                        if item["id"] == item_id:
                            self._storage.pop(i)
                            return True
                    return False
        ''').strip()
        
        (self.path / 'services.py').write_text(content)
    
    def _create_faults_file(self) -> None:
        """Create faults.py file."""
        content = textwrap.dedent(f'''
            """
            {self.name.capitalize()} module faults (error handling).
            
            Faults define domain-specific errors and their recovery strategies.
            They are automatically registered with the fault handling system.
            """
            
            from aquilia.faults import Fault, FaultDomain, Severity, RecoveryStrategy
            
            
            # Define fault domain for this module
            {self.fault_domain} = FaultDomain(
                name="{self.fault_domain}",
                description="{self.name.capitalize()} module faults",
            )
            
            
            class {self.name.capitalize()}NotFoundFault(Fault):
                """
                Raised when {self.name} item is not found.
                
                Recovery: Return 404 response
                """
                
                domain = {self.fault_domain}
                severity = Severity.LOW
                code = "{self.name.upper()}_NOT_FOUND"
                
                def __init__(self, item_id: int):
                    super().__init__(
                        message=f"{{self.name.capitalize()}} with id {{item_id}} not found",
                        context={{"item_id": item_id}},
                        recovery_strategy=RecoveryStrategy.PROPAGATE,
                    )
            
            
            class {self.name.capitalize()}ValidationFault(Fault):
                """
                Raised when {self.name} data validation fails.
                
                Recovery: Return 400 response with validation errors
                """
                
                domain = {self.fault_domain}
                severity = Severity.LOW
                code = "{self.name.upper()}_VALIDATION_ERROR"
                
                def __init__(self, errors: dict):
                    super().__init__(
                        message="Validation failed",
                        context={{"errors": errors}},
                        recovery_strategy=RecoveryStrategy.PROPAGATE,
                    )
            
            
            class {self.name.capitalize()}OperationFault(Fault):
                """
                Raised when {self.name} operation fails.
                
                Recovery: Retry with exponential backoff
                """
                
                domain = {self.fault_domain}
                severity = Severity.MEDIUM
                code = "{self.name.upper()}_OPERATION_FAILED"
                
                def __init__(self, operation: str, reason: str):
                    super().__init__(
                        message=f"Operation '{{operation}}' failed: {{reason}}",
                        context={{"operation": operation, "reason": reason}},
                        recovery_strategy=RecoveryStrategy.RETRY,
                    )
        ''').strip()
        
        (self.path / 'faults.py').write_text(content)
