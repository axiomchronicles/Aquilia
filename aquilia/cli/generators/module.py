"""Module generator."""

from pathlib import Path
from typing import List
import textwrap


class ModuleGenerator:
    """Generate Aquilia module structure."""
    
    def __init__(
        self,
        name: str,
        path: Path,
        depends_on: List[str],
        fault_domain: str,
        route_prefix: str,
        with_tests: bool = False,
    ):
        self.name = name
        self.path = path
        self.depends_on = depends_on
        self.fault_domain = fault_domain
        self.route_prefix = route_prefix
        self.with_tests = with_tests
    
    def generate(self) -> None:
        """Generate module structure."""
        self.path.mkdir(parents=True, exist_ok=True)
        
        # Create module files
        self._create_module_manifest()
        self._create_init_file()
        self._create_controllers_file()
        self._create_services_file()
        self._create_faults_file()
        
        # Optionally create test routes
        if self.with_tests:
            self._create_test_routes_file()
    
    def _create_module_manifest(self) -> None:
        """Create manifest.py with production-grade configuration."""
        deps_list = ', '.join(f'"{dep}"' for dep in self.depends_on) if self.depends_on else ''
        controller_class = f'{self.name.capitalize()}Controller'
        service_class = f'{self.name.capitalize()}Service'
        
        content = textwrap.dedent(f'''\
            """
            Production-Grade Module Manifest: {self.name}
            Generated by: aq add module {self.name}
            
            Defines complete module configuration including:
            - Services with DI scopes and lifecycle
            - Controllers with routing
            - Middleware with scoping and priority
            - Sessions with policies
            - Error handling with fault domains
            - Feature flags with conditional activation
            """
            
            from datetime import timedelta
            from aquilia import AppManifest
            from aquilia.manifest import (
                FaultHandlingConfig, FaultHandlerConfig,
                MiddlewareConfig,
                SessionConfig,
                LifecycleConfig,
                FeatureConfig,
            )
            
            
            # Production-grade manifest with complete configuration
            manifest = AppManifest(
                # Identity
                name="{self.name}",
                version="0.1.0",
                description="{self.name.capitalize()} module",
                author="team@company.com",
                tags=["{self.name}", "core"],
                
                # Services with detailed DI configuration
                services=[
                    "modules.{self.name}.services:{service_class}",
                ],
                
                # Controllers with routing
                controllers=[
                    "modules.{self.name}.controllers:{controller_class}",
                ],
                
                # Middleware configuration
                middleware=[
                    # Example middleware (uncomment to add):
                    # MiddlewareConfig(
                    #     class_path="modules.{self.name}.middleware:AuthMiddleware",
                    #     scope="app",
                    #     priority=10,
                    #     config={{}},
                    # ),
                ],
                
                # Routing configuration
                route_prefix="{self.route_prefix}",
                base_path="modules.{self.name}",
                
                # Error handling with fault domains
                faults=FaultHandlingConfig(
                    default_domain="{self.fault_domain}",
                    strategy="propagate",
                    handlers=[
                        # Example fault handler (uncomment to add):
                        # FaultHandlerConfig(
                        #     domain="{self.fault_domain}:NOT_FOUND",
                        #     handler_path="modules.{self.name}.handlers:handle_not_found",
                        # ),
                    ],
                ),
                
                # Session management
                sessions=[
                    # Example session (uncomment to add):
                    # SessionConfig(
                    #     name="{self.name}_session",
                    #     enabled=True,
                    #     ttl=timedelta(days=7),
                    #     idle_timeout=timedelta(hours=1),
                    #     transport="cookie",
                    #     store="memory",
                    # ),
                ],
                
                # Feature flags
                features=[
                    # Example feature (uncomment to add):
                    # FeatureConfig(
                    #     name="advanced_search",
                    #     enabled=False,
                    # ),
                ],
                
                # Dependencies on other modules
                depends_on=[{deps_list}],
            )
            
            
            __all__ = ["manifest"]
        ''').strip()
        
        (self.path / 'manifest.py').write_text(content)
    
    def _create_init_file(self) -> None:
        """Create __init__.py file."""
        test_import = "\nfrom .test_routes import *" if self.with_tests else ""
        
        content = textwrap.dedent(f'''
            """
            {self.name.capitalize()} Module.
            
            Generated by: aq add module {self.name}
            """
            
            from .controllers import *
            from .services import *
            from .faults import *{test_import}
            
            __module_name__ = "{self.name}"
            __version__ = "0.1.0"
        ''').strip()
        
        (self.path / '__init__.py').write_text(content)
    
    def _create_controllers_file(self) -> None:
        """Create controllers.py file with modern controller architecture."""
        content = textwrap.dedent(f'''
            """
            {self.name.capitalize()} module controllers (request handlers).
            
            This file defines the HTTP endpoints for the {self.name} module
            using the modern Controller architecture with pattern-based routing.
            """
            
            from aquilia import Controller, GET, POST, PUT, DELETE, RequestCtx, Response
            from .faults import {self.name.capitalize()}NotFoundFault
            from .services import {self.name.capitalize()}Service
            
            
            class {self.name.capitalize()}Controller(Controller):
                """
                Controller for {self.name} endpoints.
                
                Provides RESTful CRUD operations for {self.name}.
                """
                prefix = "{self.route_prefix}"
                tags = ["{self.name}"]
                
                def __init__(self, service: {self.name.capitalize()}Service):
                    self.service = service
                
                @GET("/")
                async def list_{self.name}(self, ctx: RequestCtx):
                    """
                    Get list of {self.name}.
                    
                    Example:
                        GET {self.route_prefix}/ -> {{"items": [...], "total": 0}}
                    """
                    items = await self.service.get_all()
                    
                    return Response.json({{
                        "items": items,
                        "total": len(items)
                    }})
                
                @POST("/")
                async def create_{self.name}(self, ctx: RequestCtx):
                    """
                    Create new {self.name}.
                    
                    Example:
                        POST {self.route_prefix}/
                        Body: {{"name": "Example"}}
                        -> {{"id": 1, "name": "Example"}}
                    """
                    data = await ctx.json()
                    item = await self.service.create(data)
                    return Response.json(item, status=201)
                
                @GET("/«id:int»")
                async def get_{self.name}(self, ctx: RequestCtx, id: int):
                    """
                    Get single {self.name} by ID.
                    
                    Example:
                        GET {self.route_prefix}/1 -> {{"id": 1, "name": "Example"}}
                    """
                    item = await self.service.get_by_id(id)
                    if not item:
                        raise {self.name.capitalize()}NotFoundFault(item_id=id)
                    
                    return Response.json(item)
                
                @PUT("/«id:int»")
                async def update_{self.name}(self, ctx: RequestCtx, id: int):
                    """
                    Update {self.name} by ID.
                    
                    Example:
                        PUT {self.route_prefix}/1
                        Body: {{"name": "Updated"}}
                        -> {{"id": 1, "name": "Updated"}}
                    """
                    data = await ctx.json()
                    item = await self.service.update(id, data)
                    if not item:
                        raise {self.name.capitalize()}NotFoundFault(item_id=id)
                    
                    return Response.json(item)
                
                @DELETE("/«id:int»")
                async def delete_{self.name}(self, ctx: RequestCtx, id: int):
                    """
                    Delete {self.name} by ID.
                    
                    Example:
                        DELETE {self.route_prefix}/1 -> 204 No Content
                    """
                    deleted = await self.service.delete(id)
                    if not deleted:
                        raise {self.name.capitalize()}NotFoundFault(item_id=id)
                    
                    return Response(status=204)
        ''').strip()
        
        (self.path / 'controllers.py').write_text(content)
    
    def _create_services_file(self) -> None:
        """Create services.py file."""
        content = textwrap.dedent(f'''
            """
            {self.name.capitalize()} module services (business logic).
            
            Services contain the core business logic and are auto-wired
            via dependency injection.
            """
            
            from typing import Optional, List
            from aquilia.di import service
            
            
            @service(scope="app")
            class {self.name.capitalize()}Service:
                """
                Service for {self.name} business logic.
                
                This service is automatically registered with the DI container
                and can be injected into controllers.
                """
                
                def __init__(self):
                    # TODO: Inject dependencies (e.g., repositories, external services)
                    self._storage: List[dict] = []
                    self._next_id = 1
                
                async def get_all(self) -> List[dict]:
                    """Get all items."""
                    return self._storage
                
                async def get_by_id(self, item_id: int) -> Optional[dict]:
                    """Get item by ID."""
                    for item in self._storage:
                        if item["id"] == item_id:
                            return item
                    return None
                
                async def create(self, data: dict) -> dict:
                    """Create new item."""
                    item = {{
                        "id": self._next_id,
                        **data
                    }}
                    self._storage.append(item)
                    self._next_id += 1
                    return item
                
                async def update(self, item_id: int, data: dict) -> Optional[dict]:
                    """Update existing item."""
                    item = await self.get_by_id(item_id)
                    if item:
                        item.update(data)
                    return item
                
                async def delete(self, item_id: int) -> bool:
                    """Delete item."""
                    for i, item in enumerate(self._storage):
                        if item["id"] == item_id:
                            self._storage.pop(i)
                            return True
                    return False
        ''').strip()
        
        (self.path / 'services.py').write_text(content)
    
    def _create_faults_file(self) -> None:
        """Create faults.py file."""
        # Create a valid Python variable name from fault domain
        fault_domain_var = self.fault_domain.replace(":", "_").replace("-", "_").upper()
        
        content = textwrap.dedent(f'''
            """
            {self.name.capitalize()} module faults (error handling).
            
            Faults define domain-specific errors and their recovery strategies.
            They are automatically registered with the fault handling system.
            """
            
            from aquilia.faults import Fault, FaultDomain, Severity, RecoveryStrategy
            
            
            # Define fault domain for this module
            {fault_domain_var} = FaultDomain(
                name="{self.fault_domain}",
                description="{self.name.capitalize()} module faults",
            )
            
            
            class {self.name.capitalize()}NotFoundFault(Fault):
                """
                Raised when {self.name} item is not found.
                
                Recovery: Return 404 response
                """
                
                domain = {fault_domain_var}
                severity = Severity.INFO
                code = "{self.name.upper()}_NOT_FOUND"
                
                def __init__(self, item_id: int):
                    super().__init__(
                        code=self.code,
                        domain=self.domain,
                        message=f"{self.name.capitalize()} with id {{item_id}} not found",
                        metadata={{"item_id": item_id}},
                        retryable=False,
                    )
            
            
            class {self.name.capitalize()}ValidationFault(Fault):
                """
                Raised when {self.name} data validation fails.
                
                Recovery: Return 400 response with validation errors
                """
                
                domain = {fault_domain_var}
                severity = Severity.INFO
                code = "{self.name.upper()}_VALIDATION_ERROR"
                
                def __init__(self, errors: dict):
                    super().__init__(
                        code=self.code,
                        domain=self.domain,
                        message="Validation failed",
                        metadata={{"errors": errors}},
                        retryable=False,
                    )
            
            
            class {self.name.capitalize()}OperationFault(Fault):
                """
                Raised when {self.name} operation fails.
                
                Recovery: Retry with exponential backoff
                """
                
                domain = {fault_domain_var}
                severity = Severity.WARN
                code = "{self.name.upper()}_OPERATION_FAILED"
                
                def __init__(self, operation: str, reason: str):
                    super().__init__(
                        code=self.code,
                        domain=self.domain,
                        message=f"Operation '{{operation}}' failed: {{reason}}",
                        metadata={{"operation": operation, "reason": reason}},
                        retryable=True,
                    )
        ''').strip()
        
        (self.path / 'faults.py').write_text(content)
    
    def _create_test_routes_file(self) -> None:
        """Create test_routes.py file with demo endpoints."""
        content = textwrap.dedent(f'''\
            """
            Test routes for {self.name} module - Additional test endpoints.
            """
            
            from aquilia import Controller, GET, POST, RequestCtx, Response
            
            
            class Test{self.name.capitalize()}Controller(Controller):
                """Test endpoints for {self.name} module verification."""
                
                prefix = "/test-{self.name}"
                tags = ["test", "{self.name}"]
                
                @GET("/hello")
                async def hello(self, ctx: RequestCtx):
                    """Simple hello world test endpoint."""
                    return Response.json({{
                        "message": "Hello from {{self.name}}!",
                        "status": "success",
                        "module": "{self.name}",
                        "controller": "Test{self.name.capitalize()}Controller"
                    }})
                
                @GET("/echo/«message:str»")
                async def echo(self, ctx: RequestCtx, message: str):
                    """Echo back a message with path parameter."""
                    return Response.json({{
                        "echo": message,
                        "length": len(message),
                        "type": "path_param",
                        "module": "{self.name}"
                    }})
                
                @POST("/data")
                async def post_data(self, ctx: RequestCtx):
                    """Test POST with JSON body."""
                    try:
                        data = await ctx.json()
                        return Response.json({{
                            "received": data,
                            "keys": list(data.keys()) if isinstance(data, dict) else None,
                            "status": "processed",
                            "module": "{self.name}"
                        }})
                    except Exception as e:
                        return Response.json({{
                            "error": str(e),
                            "status": "failed"
                        }}, status=400)
                
                @GET("/health")
                async def health(self, ctx: RequestCtx):
                    """Health check endpoint for {self.name} module."""
                    return Response.json({{
                        "status": "healthy",
                        "module": "{self.name}",
                        "controller": "Test{self.name.capitalize()}Controller"
                    }})
        ''').strip()
        
        (self.path / 'test_routes.py').write_text(content)
